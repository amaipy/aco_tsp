# aco_tsp

An Ant Colony Optimization algorithm developed from scratch to solve the longest path problem, implemented using Python 3.8.

It was created as an assignment for the Natural Computing course at UFMG in the first term of 2020 (01/2020).

## Instructions

* Run a test by executing on terminal:

`python main.py "\path\to\dataset.txt"`

## Implementation

The algorithm was based on the Ant Colony Optimization (ACO) implementation for the Traveling Salesman problem, 
since it is desirable to find a solution that goes through all the points of the graph without visiting a point more than once. 
It was necessary to make some adaptations, as the weight of each edge is already given in the program's input file and 
the points of the graph are not fully connected, making it have few options to assemble the path. And the objective is 
to find the path with the greatest weight, unlike the traveling salesman problem that seeks to find the shortest path 
that passes through all cities. 

The graph within the algorithm is represented as a matrix where each row is the first point, and each column represents 
which other point it can visit, and the column information stores both the point and the weight formed by the edge
between the two points. A class was created to store both the matrix with the graph and other information such as 
the number of points and the pheromone rate for all the graph edges (which initially contains the same value for all). 

To represent each ant, a class was created for storing information about the colony, graph, the weight of the path 
built by the ant, the path traced, a list with the amount of pheromone the ant will leave, which points the ant can 
visit, where the ant meets and a list with the desirability of each edge that can make up the path. 

_Desirability_ is 
calculated as the weight represented by the edge divided by 100, to keep the calculation not too large. 

The colony was 
also represented as a class, containing information such as number of ants, number of generations, α and β values 
that make up the weights in calculating the probability of choice for each edge, pheromone evaporation rate 
(a value multiplied by pheromone at update time) and a constant that is multiplied for each pheromone value at 
update time. 

The start of the ant's walk is chosen at random. For the ant to decide the next point, it is 
first checked which points it can visit from where it is at the moment. The calculation of probability follows the same 
logic presented in the concepts seen in class. 

The update of the pheromone variation to be added on edge is adapted from the ant-cycle technique discussed in the 
article _Ant system: optimization by a colony of cooperating agents (Dorigo; Maniezzo; Colorni, 1996)_, 
in which in this implementation the constant defined by the colony multiplied by the total weight of 
the path divided by 100. The ant-cycle method was chosen because it presents better results than ant-density 
and ant-quantity, which make use of local information; they do not look at the path as one all. 

At each generation of the colony, ants are created from the amount decided by parameter. 
Then, the weight of the path generated by each ant is calculated and compared with the best weight
ever found to update this information (the best weight will be the one that is larger). 
The ant's pheromone ratio is recalculated. After generating all the ants, the pheromone on each edge is 
recalculated. And after running all generations, the best path found is returned. 

In the way the algorithm was 
implemented, there were no invalid solutions, as it is always taken into account which points have already 
been visited and which ones are allowed depending on the structure of the graph. The path is built as long as there are the next valid points to be chosen.
